// Generated by CoffeeScript 1.6.1
(function() {
  var AbstractBlockContainer, BLOCK_SIZE, BLOCK_SPEED, BLOCK_TYPE_BORDER, BLOCK_TYPE_CONTAINER, BLOCK_TYPE_CONTAINER_FIRE, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_CONTAINER_STOP, BLOCK_TYPE_DIRECTION_DOWN, BLOCK_TYPE_DIRECTION_LEFT, BLOCK_TYPE_DIRECTION_RIGHT, BLOCK_TYPE_DIRECTION_UP, BLOCK_TYPE_FIRE, BLOCK_TYPE_FIRE_CLASSNAME, BLOCK_TYPE_HOLE, BLOCK_TYPE_ICE, BLOCK_TYPE_ICE_CLASSNAME, BLOCK_TYPE_STOPPER, BLOCK_TYPE_STOPPER_CLASSNAME, BlockContainer, BlockHole, Border, DirectionBlock, DrawableBlock, FireBlock, GenericBlock, Helper, IceBlock, Map, MovableBlock, OBJECT_TTL, ObjectHash, StopperBlock, TICK_SPEED, activeElement, canvas, canvasDown, canvasElements, canvasUp, ctx, currentLevel, dragGetDirection, dumpMapState, getUniqId, hashCode, i, level, levelPicker, levels, map, mapState, option, redrawCanvas, undoStates, uniqueObjectId, _i, _ref,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  levels = [["12ooooooo", "12ioioooo", "12ooFirdo", "ooio6ouoo", "oo1iooooo", "1oo11uolo"], ["xx1xx", "x1oox", "x1oxx"], ["x112x", "2ooox", "xooo1", "1ooo1"], ["xxS1x", "xdoo2", "xooox", "2ooux", "xx1xx"]];

  undoStates = [];

  /*
    Coffeescript mixins/multiple inheritance @https://gist.github.com/brandonedmark/2170758
  */


  Object.prototype.mixin = function(Klass) {
    var key, value, _ref;
    for (key in Klass) {
      value = Klass[key];
      this[key] = value;
    }
    _ref = Klass.prototype;
    for (key in _ref) {
      value = _ref[key];
      this.prototype[key] = value;
    }
    return this;
  };

  ObjectHash = (function() {

    function ObjectHash() {}

    ObjectHash.prototype.getObjectHash = function() {
      try {
        return hashCode(Object.toJSON(this));
      } catch (e) {
        return hashCode(JSON.stringify(this));
      }
    };

    return ObjectHash;

  })();

  /*
    Helpers stuff
  */


  function clone(obj) {
    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj) return obj;

    // Handle Date
    if (obj instanceof Date) {
        var copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
        var copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
        var copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
        }
        return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
};

  hashCode = function(string) {
    var char, hash, i, _i, _ref;
    hash = 0;
    if (string.length === 0) {
      return hash;
    }
    for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      char = string.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash;
  };

  BLOCK_SIZE = 64;

  BLOCK_SPEED = 16;

  TICK_SPEED = 100;

  OBJECT_TTL = 3000;

  currentLevel = {};

  BLOCK_TYPE_BORDER = 'x';

  BLOCK_TYPE_HOLE = 'o';

  BLOCK_TYPE_ICE = 'i';

  BLOCK_TYPE_STOPPER = 's';

  BLOCK_TYPE_FIRE = 'f';

  BLOCK_TYPE_CONTAINER = 'c';

  BLOCK_TYPE_CONTAINER_ICE = 'I';

  BLOCK_TYPE_CONTAINER_FIRE = 'F';

  BLOCK_TYPE_CONTAINER_STOP = 'S';

  BLOCK_TYPE_ICE_CLASSNAME = 'IceBlock';

  BLOCK_TYPE_STOPPER_CLASSNAME = 'StopperBlock';

  BLOCK_TYPE_FIRE_CLASSNAME = 'FireBlock';

  BLOCK_TYPE_DIRECTION_UP = 'u';

  BLOCK_TYPE_DIRECTION_LEFT = 'l';

  BLOCK_TYPE_DIRECTION_DOWN = 'd';

  BLOCK_TYPE_DIRECTION_RIGHT = 'r';

  canvasElements = {};

  canvas = document.getElementById('canvas');

  canvas.valid = false;

  ctx = canvas.getContext('2d');

  activeElement = false;

  canvasDown = function(e) {
    var element, id, x, y, _results;
    x = e.pageX - canvas.offsetLeft;
    y = e.pageY - canvas.offsetTop;
    canvas.dragX = x;
    canvas.dragY = y;
    _results = [];
    for (id in canvasElements) {
      element = canvasElements[id];
      if (typeof element === 'object') {
        if (y > element.canvasY && y < element.canvasY + element.height && x > element.canvasX && x < element.canvasX + element.width) {
          _results.push(activeElement = element);
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  uniqueObjectId = 0;

  getUniqId = function() {
    return uniqueObjectId += 1;
  };

  canvasUp = function(e) {
    var blockElem, lastTime, neighbCellCoords, x, y, _i, _len, _ref, _results;
    if (activeElement.blockCount === 0 && activeElement.blockType === BLOCK_TYPE_CONTAINER && undoStates.length > 0) {
      lastTime = undoStates.pop();
      map.loadMap(lastTime);
      canvas.valid = false;
    }
    x = e.pageX - canvas.offsetLeft;
    y = e.pageY - canvas.offsetTop;
    if (dragGetDirection(canvas.dragX, canvas.dragY, x, y) !== false) {
      neighbCellCoords = Helper.getNeighborCellByDirection(dragGetDirection(canvas.dragX, canvas.dragY, x, y), ~~(this.dragX / BLOCK_SIZE), ~~(this.dragY / BLOCK_SIZE));
      if (map.isCellAvailableForMoveOver(neighbCellCoords[1], neighbCellCoords[0]) && activeElement.blockCount > 0) {
        undoStates.push(dumpMapState());
        activeElement.spawnBlocks();
        _ref = activeElement.blockList;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          blockElem = _ref[_i];
          _results.push(blockElem.setDirection(dragGetDirection(canvas.dragX, canvas.dragY, x, y)));
        }
        return _results;
      }
    }
  };

  dragGetDirection = function(xf, yf, xt, yt) {
    if (xf === xt && yf === yt) {
      return false;
    }
    if (xf > xt) {
      return 'left';
    }
    if (xf + BLOCK_SIZE < xt) {
      return 'right';
    }
    if (yf < yt) {
      return 'down';
    }
    if (yf + BLOCK_SIZE > yt) {
      return 'up';
    }
  };

  canvas.onmousedown = canvasDown;

  canvas.onmouseup = canvasUp;

  redrawCanvas = function() {
    var element, id;
    if (!canvas.valid) {
      for (id in canvasElements) {
        element = canvasElements[id];
        if (typeof element === 'object') {
          ctx.globalAlpha = 1;
          if (element.transparency > 0) {
            ctx.globalAlpha = 1;
          }
          ctx.fillStyle = element.blockColor;
          if (typeof element === 'object') {
            element.drawOnCtx(ctx, element.canvasX, element.canvasY, element.width, element.height);
          }
        }
      }
      return canvas.valid = true;
    }
  };

  Map = (function() {

    function Map(levelMap) {
      var _this = this;
      this.tick = function() {
        return Map.prototype.tick.apply(_this, arguments);
      };
      this.listeners = {};
      this.loadMap(levelMap);
      this.tick();
    }

    Map.prototype.addListener = function(obj) {
      obj.ttl = OBJECT_TTL;
      return this.listeners[obj.id] = obj;
    };

    Map.prototype.removeListener = function(obj) {
      return delete this.listeners[obj.id];
    };

    Map.prototype.updateListeners = function() {
      var listener, listenerId, _ref, _results;
      _ref = this.listeners;
      _results = [];
      for (listenerId in _ref) {
        listener = _ref[listenerId];
        if (listener.state === 'active') {
          if (listener.movable === false || listener.ttl < 0) {
            _results.push(this.removeListener(listener));
          } else {
            listener[listener['doEvent']]();
            _results.push(listener.ttl -= 1);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Map.prototype.tick = function() {
      this.updateListeners();
      redrawCanvas();
      if (this.checkIfMapIsComplete()) {
        console.log('Congratulations!');
      }
      return setTimeout(this.tick, TICK_SPEED);
    };

    Map.prototype.loadMap = function(levelMap) {
      var blockCount, item, row, x, y;
      canvasElements = {};
      currentLevel = {};
      this.cells = (function() {
        var _i, _ref, _results;
        _results = [];
        for (y = _i = 0, _ref = levelMap.length; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
          row = levelMap[y].split(/(?:)/);
          _results.push((function() {
            var _j, _ref1, _ref2, _results1;
            _results1 = [];
            for (x = _j = 0, _ref1 = row.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
              blockCount = -1;
              switch (row[x]) {
                case BLOCK_TYPE_ICE:
                  item = new IceBlock(blockCount, BLOCK_TYPE_ICE);
                  break;
                case BLOCK_TYPE_HOLE:
                  item = new BlockHole();
                  break;
                case BLOCK_TYPE_FIRE:
                  item = new FireBlock(blockCount, BLOCK_TYPE_FIRE);
                  break;
                case BLOCK_TYPE_STOPPER:
                  item = new StopperBlock(blockCount, BLOCK_TYPE_STOPPER);
                  break;
                case '0':
                  item = new BlockContainer(0, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '1':
                  item = new BlockContainer(1, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '2':
                  item = new BlockContainer(2, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '3':
                  item = new BlockContainer(3, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '4':
                  item = new BlockContainer(4, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '5':
                  item = new BlockContainer(5, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '6':
                  item = new BlockContainer(6, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case BLOCK_TYPE_CONTAINER_STOP:
                  item = new BlockContainer(1, BLOCK_TYPE_CONTAINER_STOP, BLOCK_TYPE_STOPPER);
                  break;
                case BLOCK_TYPE_CONTAINER_FIRE:
                  item = new BlockContainer(1, BLOCK_TYPE_CONTAINER_FIRE, BLOCK_TYPE_FIRE);
                  break;
                case BLOCK_TYPE_DIRECTION_UP:
                  item = new DirectionBlock(BLOCK_TYPE_DIRECTION_UP);
                  break;
                case BLOCK_TYPE_DIRECTION_DOWN:
                  item = new DirectionBlock(BLOCK_TYPE_DIRECTION_DOWN);
                  break;
                case BLOCK_TYPE_DIRECTION_LEFT:
                  item = new DirectionBlock(BLOCK_TYPE_DIRECTION_LEFT);
                  break;
                case BLOCK_TYPE_DIRECTION_RIGHT:
                  item = new DirectionBlock(BLOCK_TYPE_DIRECTION_RIGHT);
                  break;
                default:
                  item = new Border(blockCount, BLOCK_TYPE_BORDER);
              }
              if ((_ref2 = currentLevel[x]) == null) {
                currentLevel[x] = {};
              }
              item.setXY(x, y);
              currentLevel[x][y] = item;
              _results1.push(canvasElements[item.id] = item);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      return canvas.valid = false;
    };

    Map.prototype.checkIfMapIsComplete = function() {
      var k1, k2, v1, v2;
      for (k1 in currentLevel) {
        v1 = currentLevel[k1];
        for (k2 in v1) {
          v2 = v1[k2];
          if (v2.blockType === BLOCK_TYPE_HOLE) {
            return false;
          }
        }
      }
      return true;
    };

    Map.prototype.isCellAvailableForMoveOver = function(y, x) {
      var _ref;
      if (typeof currentLevel[x] === 'object') {
        if ((_ref = currentLevel[x][y].blockType) === BLOCK_TYPE_HOLE || _ref === BLOCK_TYPE_ICE || _ref === BLOCK_TYPE_DIRECTION_DOWN || _ref === BLOCK_TYPE_DIRECTION_LEFT || _ref === BLOCK_TYPE_DIRECTION_RIGHT || _ref === BLOCK_TYPE_DIRECTION_UP) {
          return true;
        }
      }
      return false;
    };

    Map.prototype.updateBlockPositionOnMap = function(blockObj) {
      var hole;
      if (blockObj.canvasX / BLOCK_SIZE > blockObj.x || (blockObj.canvasX / BLOCK_SIZE) === (blockObj.x - 1)) {
        blockObj.x = ~~(blockObj.canvasX / BLOCK_SIZE);
      }
      if ((blockObj.canvasY / BLOCK_SIZE) > blockObj.y || (blockObj.canvasY / BLOCK_SIZE) === (blockObj.y - 1)) {
        blockObj.y = ~~(blockObj.canvasY / BLOCK_SIZE);
      }
      if (blockObj.x * BLOCK_SIZE === blockObj.canvasX && blockObj.y * BLOCK_SIZE === blockObj.canvasY) {
        switch (currentLevel[blockObj.x][blockObj.y].blockType) {
          case BLOCK_TYPE_HOLE:
            blockObj.movable = false;
            currentLevel[blockObj.x][blockObj.y] = blockObj;
            break;
          case BLOCK_TYPE_DIRECTION_UP:
            blockObj.setDirection('up');
            break;
          case BLOCK_TYPE_DIRECTION_DOWN:
            blockObj.setDirection('down');
            break;
          case BLOCK_TYPE_DIRECTION_LEFT:
            blockObj.setDirection('left');
            break;
          case BLOCK_TYPE_DIRECTION_RIGHT:
            blockObj.setDirection('right');
            break;
          case BLOCK_TYPE_ICE:
            if (blockObj.blockType === BLOCK_TYPE_FIRE) {
              hole = new BlockHole(BLOCK_TYPE_HOLE);
              hole.setXY(canvasElements[currentLevel[blockObj.x][blockObj.y].id].x, canvasElements[currentLevel[blockObj.x][blockObj.y].id].y);
              canvasElements[currentLevel[blockObj.x][blockObj.y].id] = hole;
            }
        }
      }
      return true;
    };

    return Map;

  })();

  DrawableBlock = (function() {

    function DrawableBlock() {}

    DrawableBlock.prototype.drawOnCtx = function(ctx, x, y, w, h) {
      var gradient;
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.closePath();
      ctx.fill();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, ctx.fillStyle);
      gradient.addColorStop(1, ctx.fillStyle);
      ctx.shadowBlur = 1;
      ctx.shadowColor = "black";
      ctx.fillStyle = gradient;
      ctx.fill();
      return this.drawSymbol(ctx, x, y, w, h);
    };

    DrawableBlock.prototype.drawSymbol = function(ctx, x, y, w, h) {
      switch (this.blockType) {
        case BLOCK_TYPE_ICE:
          return this.drawIceSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_FIRE:
          return this.drawFireSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_DIRECTION_DOWN:
          return this.drawDownSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_DIRECTION_LEFT:
          return this.drawLeftSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_DIRECTION_RIGHT:
          return this.drawRightSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_DIRECTION_UP:
          return this.drawUpSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_CONTAINER:
          return this.drawContainerSymbol(ctx, x, y, w, h);
      }
    };

    DrawableBlock.prototype.drawContainerSymbol = function(ctx, x, y, w, h) {
      if (this.blockCount > 0) {
        ctx.fillStyle = "black";
        ctx.font = "bold 16px Arial";
        return ctx.fillText(this.blockCount + ":" + this.blockChildType, x + w / 10, y + h / 2);
      } else {
        return this.drawUndoSymbol(ctx, x, y, w, h);
      }
    };

    DrawableBlock.prototype.drawUndoSymbol = function(ctx, x, y, w, h) {
      ctx.fillStyle = "black";
      ctx.font = "bold 16px Arial";
      ctx.fillText("UNDO", x + w / 10, y + h / 2);
    };

    DrawableBlock.prototype.drawIceSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y + offset);
      ctx.lineTo(x + w - offset * 2, y + h / 2);
      ctx.lineTo(x + w / 2, y + h - offset);
      ctx.lineTo(x + offset * 2, y + h / 2);
      ctx.closePath();
      ctx.shadowBlur = 0;
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FFFFFF");
      gradient.addColorStop(1, "#9fbae0");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawFireSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y + offset);
      ctx.lineTo(x + w - offset * 2, y + h / 2);
      ctx.lineTo(x + w / 2, y + h - offset);
      ctx.lineTo(x + offset * 2, y + h / 2);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FF3333");
      gradient.addColorStop(1, "#9f3333");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawUpSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y + offset);
      ctx.lineTo(x + w - offset, y + h - offset);
      ctx.lineTo(x + offset, y + h - offset);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#fff");
      gradient.addColorStop(1, "#ccc");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawDownSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + offset, y + offset);
      ctx.lineTo(x + w - offset, y + offset);
      ctx.lineTo(x + w / 2, y + h - offset);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FF3333");
      gradient.addColorStop(1, "#9f3333");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawLeftSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + offset, y + h / 2);
      ctx.lineTo(x + w - offset, y + offset);
      ctx.lineTo(x + w - offset, y + h - offset);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FF3333");
      gradient.addColorStop(1, "#9f3333");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawRightSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + offset, y + offset);
      ctx.lineTo(x + w - offset, y + h / 2);
      ctx.lineTo(x + offset, y + h - offset);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FF3333");
      gradient.addColorStop(1, "#9f3333");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    return DrawableBlock;

  })();

  MovableBlock = (function() {

    function MovableBlock() {}

    MovableBlock.prototype.enableBlock = function() {
      this.state = 'active';
      this.doEvent = 'moveBlock';
      return map.addListener(this);
    };

    MovableBlock.prototype.setDirection = function(direction) {
      this.direction = direction;
      this.direction = direction;
      if (this.state !== 'active') {
        return this.enableBlock();
      }
    };

    MovableBlock.prototype.getDirection = function() {
      return this.direction;
    };

    MovableBlock.prototype.updateBlockPosition = function() {};

    MovableBlock.prototype.moveBlock = function() {
      var a;
      a = this.canvasX + this.canvasY;
      switch (this.direction) {
        case 'left':
          if (map.isCellAvailableForMoveOver(this.y, this.x - 1)) {
            this.modifyCanvasX(-BLOCK_SPEED);
          }
          break;
        case 'right':
          if (map.isCellAvailableForMoveOver(this.y, this.x + 1)) {
            this.modifyCanvasX(BLOCK_SPEED);
          }
          break;
        case 'up':
          if (map.isCellAvailableForMoveOver(this.y - 1, this.x)) {
            this.modifyCanvasY(-BLOCK_SPEED);
          }
          break;
        case 'down':
          if (map.isCellAvailableForMoveOver(this.y + 1, this.x)) {
            this.modifyCanvasY(BLOCK_SPEED);
          }
          break;
        default:
          throw {
            message: 'no direction were set'
          };
      }
      if (this.canvasX + this.canvasY !== a) {
        canvas.valid = false;
      }
      return false;
    };

    MovableBlock.prototype.checkBlockStatus = function() {
      if (this.direction === false) {
        this.state = false;
        return map.deleteListener(this);
      }
    };

    MovableBlock.prototype.setMoveTo = function(moveToX, moveToY) {
      this.moveToX = moveToX;
      this.moveToY = moveToY;
    };

    MovableBlock;

    return MovableBlock;

  })();

  GenericBlock = (function(_super) {

    __extends(GenericBlock, _super);

    GenericBlock.mixin(ObjectHash);

    GenericBlock.mixin(MovableBlock);

    function GenericBlock(blockType) {
      this.id = getUniqId();
      this.blockType = blockType;
      this.x = 0;
      this.y = 0;
      this.canvasX = 0;
      this.canvasY = 0;
      this.movable = true;
      this.direction = false;
      this.width = BLOCK_SIZE;
      this.height = BLOCK_SIZE;
    }

    GenericBlock.prototype.modifyCanvasX = function(modifier) {
      var boundLeft, boundRight, moveDirection;
      moveDirection = modifier < 0 ? -1 : 1;
      if (this.nextDirectionModifier !== '') {
        if (this.direction === this.direction_old && currentLevel[this.x + moveDirection][this.y].blockType === BLOCK_TYPE_HOLE) {
          modifier = this.nextDirectionModifier;
          this.nextDirectionModifier = '';
        } else {
          this.nextDirectionModifier = '';
        }
      }
      this.canvasX += modifier;
      boundLeft = this.width * (~~(this.canvasX / this.width));
      boundRight = this.width * (~~(this.canvasX / this.width) + 1);
      if ((this.canvasX + modifier) < boundLeft && currentLevel[this.x + moveDirection][this.y].blockType === BLOCK_TYPE_HOLE) {
        this.nextDirectionModifier = boundLeft - this.canvasX;
      }
      if ((this.canvasX + modifier) >= boundRight && currentLevel[this.x + moveDirection][this.y].blockType === BLOCK_TYPE_HOLE) {
        this.nextDirectionModifier = boundRight - this.canvasX;
      }
      this.direction_old = this.direction;
      return map.updateBlockPositionOnMap(this);
    };

    GenericBlock.prototype.modifyCanvasY = function(modifier) {
      var boundBottom, boundTop, moveDirection, _ref, _ref1;
      moveDirection = modifier < 0 ? -1 : 1;
      if (this.nextDirectionModifier !== '') {
        if (this.direction === this.direction_old) {
          modifier = this.nextDirectionModifier;
          this.nextDirectionModifier = '';
        } else {
          this.nextDirectionModifier = '';
        }
      }
      this.canvasY += modifier;
      boundTop = this.height * (~~(this.canvasY / this.height));
      boundBottom = this.height * (~~(this.canvasY / this.height) + 1);
      if ((this.canvasY + modifier) < boundTop && ((_ref = currentLevel[this.x][this.y + moveDirection]) === BLOCK_TYPE_HOLE || _ref === BLOCK_TYPE_DIRECTION_UP || _ref === BLOCK_TYPE_DIRECTION_DOWN || _ref === BLOCK_TYPE_DIRECTION_LEFT || _ref === BLOCK_TYPE_DIRECTION_RIGHT)) {
        this.nextDirectionModifier = boundTop - this.canvasY;
      }
      if ((this.canvasY + modifier) > boundBottom && ((_ref1 = currentLevel[this.x][this.y + moveDirection]) === BLOCK_TYPE_HOLE || _ref1 === BLOCK_TYPE_DIRECTION_UP || _ref1 === BLOCK_TYPE_DIRECTION_DOWN || _ref1 === BLOCK_TYPE_DIRECTION_LEFT || _ref1 === BLOCK_TYPE_DIRECTION_RIGHT)) {
        this.nextDirectionModifier = boundBottom - this.canvasY;
      }
      this.direction_old = this.direction;
      return map.updateBlockPositionOnMap(this);
    };

    GenericBlock.prototype.setCanvasXY = function(canvasX, canvasY) {
      this.canvasX = canvasX;
      this.canvasY = canvasY;
    };

    GenericBlock.prototype.setXY = function(x, y) {
      this.x = x;
      this.y = y;
      this.canvasX = BLOCK_SIZE * this.x;
      return this.canvasY = BLOCK_SIZE * this.y;
    };

    return GenericBlock;

  })(DrawableBlock);

  DirectionBlock = (function(_super) {

    __extends(DirectionBlock, _super);

    function DirectionBlock(type) {
      DirectionBlock.__super__.constructor.call(this, type);
      this.blockColor = '#335577';
      this.transparency = 0.3;
    }

    return DirectionBlock;

  })(GenericBlock);

  IceBlock = (function(_super) {

    __extends(IceBlock, _super);

    function IceBlock() {
      IceBlock.__super__.constructor.call(this, BLOCK_TYPE_ICE);
      this.blockColor = '#000077';
      this.transparency = 0.3;
    }

    return IceBlock;

  })(GenericBlock);

  FireBlock = (function(_super) {

    __extends(FireBlock, _super);

    function FireBlock() {
      FireBlock.__super__.constructor.call(this, BLOCK_TYPE_FIRE);
      this.blockColor = '#FF1111';
      this.transparency = 0.3;
    }

    return FireBlock;

  })(GenericBlock);

  StopperBlock = (function(_super) {

    __extends(StopperBlock, _super);

    function StopperBlock() {
      StopperBlock.__super__.constructor.call(this, BLOCK_TYPE_STOPPER);
      this.blockColor = '#115090';
    }

    return StopperBlock;

  })(GenericBlock);

  AbstractBlockContainer = (function(_super) {
    var blockCount, blockType;

    __extends(AbstractBlockContainer, _super);

    blockType = '';

    blockCount = 0;

    function AbstractBlockContainer() {
      this.x = 0;
      this.y = 0;
      this.id = getUniqId();
      this.width = BLOCK_SIZE;
      this.height = BLOCK_SIZE;
    }

    AbstractBlockContainer.prototype.setCanvasXY = function(canvasX, canvasY) {
      this.canvasX = canvasX;
      this.canvasY = canvasY;
    };

    AbstractBlockContainer.prototype.setXY = function(x, y) {
      this.x = x;
      this.y = y;
      this.canvasX = BLOCK_SIZE * this.x;
      return this.canvasY = BLOCK_SIZE * this.y;
    };

    return AbstractBlockContainer;

  })(DrawableBlock);

  BlockContainer = (function(_super) {

    __extends(BlockContainer, _super);

    function BlockContainer(blockCount, blockContainerType, blockChildType) {
      this.blockContainerType = blockContainerType;
      this.blockChildType = blockChildType;
      BlockContainer.__super__.constructor.apply(this, arguments);
      this.blockCount = blockCount;
      this.blockType = BLOCK_TYPE_CONTAINER;
      this.blockChildTypeClass = Helper.getBlockClassName(blockChildType);
      this.blockList = [];
      this.blockColor = "#FFF";
    }

    BlockContainer.prototype.spawnBlocks = function() {
      var block, i, _i, _ref;
      for (i = _i = 0, _ref = this.blockCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        block = eval("new " + this.blockChildTypeClass + "()");
        block.setXY(this.x, this.y);
        canvasElements[block.id] = block;
        this.blockList.push(block);
      }
      this.blockCount = 0;
      return canvas.valid = false;
    };

    return BlockContainer;

  })(AbstractBlockContainer);

  BlockHole = (function(_super) {

    __extends(BlockHole, _super);

    function BlockHole() {
      BlockHole.__super__.constructor.apply(this, arguments);
      this.blockType = BLOCK_TYPE_HOLE;
      this.blockColor = "#eeeeee";
    }

    return BlockHole;

  })(AbstractBlockContainer);

  Border = (function(_super) {

    __extends(Border, _super);

    function Border() {
      this.className = 'border';
      Border.__super__.constructor.apply(this, arguments);
      this.blockType = BLOCK_TYPE_BORDER;
      this.blockColor = "#000000";
    }

    return Border;

  })(AbstractBlockContainer);

  Helper = (function() {

    function Helper() {}

    Helper.getNeighborCellByDirection = function(direction, x, y) {
      switch (direction) {
        case 'left':
          return [x - 1, y];
        case 'right':
          return [x + 1, y];
        case 'up':
          return [x, y - 1];
        case 'down':
          return [x, y + 1];
        default:
          throw {
            message: 'lolwut?'
          };
      }
    };

    Helper.getBlockClassName = function(className) {
      switch (className) {
        case BLOCK_TYPE_FIRE:
          return BLOCK_TYPE_FIRE_CLASSNAME;
        case BLOCK_TYPE_STOPPER:
          return BLOCK_TYPE_STOPPER_CLASSNAME;
        case BLOCK_TYPE_ICE:
          return BLOCK_TYPE_ICE_CLASSNAME;
      }
    };

    return Helper;

  })();

  level = parseInt(location.search.substr(1), 10) || 1;

  map = new Map(levels[level - 1]);

  levelPicker = document.getElementById('level');

  for (i = _i = 1, _ref = levels.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
    option = document.createElement('option');
    option.value = i;
    option.appendChild(document.createTextNode("Level " + i));
    levelPicker.appendChild(option);
  }

  levelPicker.value = level;

  levelPicker.addEventListener('change', function() {
    return location.search = '?' + levelPicker.value;
  });

  mapState = [];

  document.getElementById('reset').addEventListener('click', function() {
    return mapState = dumpMapState();
  });

  document.getElementById('debug').addEventListener('click', function() {
    return map.loadMap(mapState);
  });

  dumpMapState = function() {
    var j, k, tmp, v1, v2, _ref1;
    mapState = [];
    for (k in currentLevel) {
      v1 = currentLevel[k];
      if (typeof v1 === 'object') {
        tmp = '';
        for (j in v1) {
          v2 = v1[j];
          if (typeof v2 === 'object') {
            if ((_ref1 = mapState[j]) == null) {
              mapState[j] = '';
            }
            switch (v2.blockType) {
              case BLOCK_TYPE_CONTAINER:
                if (v2.blockContainerType === BLOCK_TYPE_CONTAINER_ICE) {
                  mapState[j] += v2.blockCount;
                } else if (v2.blockCount > 0 && v2.blockChildType) {
                  mapState[j] += v2.blockContainerType;
                } else {
                  mapState[j] += v2.blockContainerType;
                }
                break;
              default:
                mapState[j] += v2.blockType;
            }
          }
        }
      }
    }
    return mapState;
  };

}).call(this);
