// Generated by CoffeeScript 1.6.1
(function() {
  var AbstractBlockContainer, BLOCK_SIZE, BLOCK_SPEED, BLOCK_TYPE_BORDER, BLOCK_TYPE_CONTAINER, BLOCK_TYPE_CONTAINER_FIRE, BLOCK_TYPE_CONTAINER_FIRE_EMPTY, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_CONTAINER_STOP, BLOCK_TYPE_CONTAINER_STOP_EMPTY, BLOCK_TYPE_DIRECTION_DOWN, BLOCK_TYPE_DIRECTION_LEFT, BLOCK_TYPE_DIRECTION_RIGHT, BLOCK_TYPE_DIRECTION_UP, BLOCK_TYPE_FIRE, BLOCK_TYPE_FIRE_CLASSNAME, BLOCK_TYPE_HOLE, BLOCK_TYPE_ICE, BLOCK_TYPE_ICE_CLASSNAME, BLOCK_TYPE_STOPPER, BLOCK_TYPE_STOPPER_CLASSNAME, BlockContainer, BlockHole, Border, DirectionBlock, DrawableBlock, FireBlock, GenericBlock, Helper, IceBlock, Map, MovableBlock, OBJECT_TTL, ObjectHash, StopperBlock, TICK_SPEED, activeElement, canvas, canvasDown, canvasElements, canvasUp, ctx, currentLevel, dragGetDirection, dumpMapState, getUniqId, hashCode, i, level, levelPicker, levels, map, mapState, option, redrawCanvas, undoStates, uniqueObjectId, _i, _ref,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  levels = [["12ooooooo", "12ioioooo", "12ooFirdo", "ooio6ouoo", "oo1iooooo", "1oo11uolo"], ["xx1xx", "x1oox", "x1oxx"], ["x112x", "2ooox", "xooo1", "1ooo1"], ["xxS1x", "xdoo2", "xooox", "2ooux", "xx1xx"]];

  undoStates = [];

  /*
    Coffeescript mixins/multiple inheritance @https://gist.github.com/brandonedmark/2170758
  */


  Object.prototype.mixin = function(Klass) {
    var key, value, _ref;
    for (key in Klass) {
      value = Klass[key];
      this[key] = value;
    }
    _ref = Klass.prototype;
    for (key in _ref) {
      value = _ref[key];
      this.prototype[key] = value;
    }
    return this;
  };

  ObjectHash = (function() {

    function ObjectHash() {}

    ObjectHash.prototype.getObjectHash = function() {
      try {
        return hashCode(Object.toJSON(this));
      } catch (e) {
        return hashCode(JSON.stringify(this));
      }
    };

    return ObjectHash;

  })();

  /*
    Helpers stuff
  */


  function clone(obj) {
    // Handle the 3 simple types, and null or undefined
    if (null == obj || "object" != typeof obj) return obj;

    // Handle Date
    if (obj instanceof Date) {
        var copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
        var copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            copy[i] = clone(obj[i]);
        }
        return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
        var copy = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
        }
        return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
};

  hashCode = function(string) {
    var char, hash, i, _i, _ref;
    hash = 0;
    if (string.length === 0) {
      return hash;
    }
    for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      char = string.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash;
  };

  BLOCK_SIZE = 64;

  BLOCK_SPEED = 16;

  TICK_SPEED = 100;

  OBJECT_TTL = 3000;

  currentLevel = {};

  BLOCK_TYPE_BORDER = 'x';

  BLOCK_TYPE_HOLE = 'o';

  BLOCK_TYPE_ICE = 'i';

  BLOCK_TYPE_STOPPER = 's';

  BLOCK_TYPE_FIRE = 'f';

  BLOCK_TYPE_CONTAINER = 'c';

  BLOCK_TYPE_CONTAINER_ICE = 'I';

  BLOCK_TYPE_CONTAINER_FIRE = 'F';

  BLOCK_TYPE_CONTAINER_STOP = 'S';

  BLOCK_TYPE_CONTAINER_FIRE_EMPTY = 'Ꝼ';

  BLOCK_TYPE_CONTAINER_STOP_EMPTY = 'Ś';

  BLOCK_TYPE_ICE_CLASSNAME = 'IceBlock';

  BLOCK_TYPE_STOPPER_CLASSNAME = 'StopperBlock';

  BLOCK_TYPE_FIRE_CLASSNAME = 'FireBlock';

  BLOCK_TYPE_DIRECTION_UP = 'u';

  BLOCK_TYPE_DIRECTION_LEFT = 'l';

  BLOCK_TYPE_DIRECTION_DOWN = 'd';

  BLOCK_TYPE_DIRECTION_RIGHT = 'r';

  canvasElements = {};

  canvas = document.getElementById('canvas');

  canvas.valid = false;

  ctx = canvas.getContext('2d');

  activeElement = false;

  canvasDown = function(e) {
    var element, id, x, y, _results;
    x = e.pageX - canvas.offsetLeft;
    y = e.pageY - canvas.offsetTop;
    canvas.dragX = x;
    canvas.dragY = y;
    _results = [];
    for (id in canvasElements) {
      element = canvasElements[id];
      if (typeof element === 'object') {
        if (y > element.canvasY && y < element.canvasY + element.height && x > element.canvasX && x < element.canvasX + element.width) {
          _results.push(activeElement = element);
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  uniqueObjectId = 0;

  getUniqId = function() {
    return uniqueObjectId += 1;
  };

  canvasUp = function(e) {
    var a, blockElem, lastTime, neighbCellCoords, x, y, _i, _len, _ref, _results;
    if (activeElement.blockCount === 0 && activeElement.blockType === BLOCK_TYPE_CONTAINER && undoStates.length > 0) {
      lastTime = undoStates.pop();
      console.debug("Restoring ", lastTime);
      map.loadMap(lastTime);
      canvas.valid = false;
    }
    x = e.pageX - canvas.offsetLeft;
    y = e.pageY - canvas.offsetTop;
    if (dragGetDirection(canvas.dragX, canvas.dragY, x, y) !== false) {
      neighbCellCoords = Helper.getNeighborCellByDirection(dragGetDirection(canvas.dragX, canvas.dragY, x, y), ~~(this.dragX / BLOCK_SIZE), ~~(this.dragY / BLOCK_SIZE));
      if (map.isCellAvailableForMoveOver(neighbCellCoords[1], neighbCellCoords[0]) && activeElement.blockCount > 0) {
        a = dumpMapState();
        undoStates.push(a);
        console.debug("Memorized:", a);
        activeElement.spawnBlocks();
        _ref = activeElement.blockList;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          blockElem = _ref[_i];
          _results.push(blockElem.setDirection(dragGetDirection(canvas.dragX, canvas.dragY, x, y)));
        }
        return _results;
      }
    }
  };

  dragGetDirection = function(xf, yf, xt, yt) {
    if (xf === xt && yf === yt) {
      return false;
    }
    if (xf > xt) {
      return 'left';
    }
    if (xf + BLOCK_SIZE < xt) {
      return 'right';
    }
    if (yf < yt) {
      return 'down';
    }
    if (yf + BLOCK_SIZE > yt) {
      return 'up';
    }
  };

  canvas.onmousedown = canvasDown;

  canvas.onmouseup = canvasUp;

  redrawCanvas = function() {
    var element, id;
    if (!canvas.valid) {
      for (id in canvasElements) {
        element = canvasElements[id];
        if (typeof element === 'object') {
          ctx.globalAlpha = 1;
          if (element.transparency > 0) {
            ctx.globalAlpha = 1;
          }
          ctx.fillStyle = element.blockColor;
          if (typeof element === 'object') {
            element.drawOnCtx(ctx, element.canvasX, element.canvasY, element.width, element.height);
          }
        }
      }
      return canvas.valid = true;
    }
  };

  Map = (function() {

    function Map(levelMap) {
      var _this = this;
      this.tick = function() {
        return Map.prototype.tick.apply(_this, arguments);
      };
      this.listeners = {};
      this.loadMap(levelMap);
      this.tick();
    }

    Map.prototype.addListener = function(obj) {
      obj.ttl = OBJECT_TTL;
      return this.listeners[obj.id] = obj;
    };

    Map.prototype.removeListener = function(obj) {
      return delete this.listeners[obj.id];
    };

    Map.prototype.updateListeners = function() {
      var listener, listenerId, _ref, _results;
      _ref = this.listeners;
      _results = [];
      for (listenerId in _ref) {
        listener = _ref[listenerId];
        if (listener.state === 'active') {
          if (listener.movable === false || listener.ttl < 0) {
            _results.push(this.removeListener(listener));
          } else {
            listener[listener['doEvent']]();
            _results.push(listener.ttl -= 1);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Map.prototype.tick = function() {
      this.updateListeners();
      redrawCanvas();
      if (this.checkIfMapIsComplete()) {
        console.log('Congratulations!');
      }
      return setTimeout(this.tick, TICK_SPEED);
    };

    Map.prototype.loadMap = function(levelMap) {
      var blockCount, item, row, x, y;
      canvasElements = {};
      currentLevel = {};
      console.debug("Loading: ", levelMap);
      console.debug("Cur/Canv: ", currentLevel, canvasElements);
      this.cells = (function() {
        var _i, _ref, _results;
        _results = [];
        for (y = _i = 0, _ref = levelMap.length; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
          row = levelMap[y].split(/(?:)/);
          _results.push((function() {
            var _j, _ref1, _ref2, _results1;
            _results1 = [];
            for (x = _j = 0, _ref1 = row.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
              blockCount = -1;
              switch (row[x]) {
                case BLOCK_TYPE_ICE:
                  console.log(BLOCK_TYPE_ICE + (" for " + (x + 1) + ":" + (y + 1) + " "));
                  item = new IceBlock(blockCount, BLOCK_TYPE_ICE);
                  break;
                case BLOCK_TYPE_HOLE:
                  item = new BlockHole();
                  break;
                case BLOCK_TYPE_FIRE:
                  item = new FireBlock(blockCount, BLOCK_TYPE_FIRE);
                  break;
                case BLOCK_TYPE_STOPPER:
                  item = new StopperBlock(blockCount, BLOCK_TYPE_STOPPER);
                  break;
                case '0':
                  console.log(BLOCK_TYPE_CONTAINER_ICE + (" 0 for " + (x + 1) + ":" + (y + 1) + " "));
                  item = new BlockContainer(0, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '1':
                  console.log(BLOCK_TYPE_CONTAINER_ICE + (" 1 for " + (x + 1) + ":" + (y + 1) + " "));
                  item = new BlockContainer(1, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '2':
                  item = new BlockContainer(2, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '3':
                  item = new BlockContainer(3, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '4':
                  item = new BlockContainer(4, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '5':
                  item = new BlockContainer(5, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case '6':
                  item = new BlockContainer(6, BLOCK_TYPE_CONTAINER_ICE, BLOCK_TYPE_ICE);
                  break;
                case BLOCK_TYPE_CONTAINER_STOP:
                  item = new BlockContainer(1, BLOCK_TYPE_CONTAINER_STOP, BLOCK_TYPE_STOPPER);
                  break;
                case BLOCK_TYPE_CONTAINER_STOP_EMPTY:
                  item = new BlockContainer(0, BLOCK_TYPE_CONTAINER_STOP, BLOCK_TYPE_STOPPER);
                  break;
                case BLOCK_TYPE_CONTAINER_FIRE:
                  item = new BlockContainer(1, BLOCK_TYPE_CONTAINER_FIRE, BLOCK_TYPE_FIRE);
                  break;
                case BLOCK_TYPE_CONTAINER_FIRE_EMPTY:
                  item = new BlockContainer(0, BLOCK_TYPE_CONTAINER_FIRE, BLOCK_TYPE_FIRE);
                  break;
                case BLOCK_TYPE_DIRECTION_UP:
                  item = new DirectionBlock(BLOCK_TYPE_DIRECTION_UP);
                  break;
                case BLOCK_TYPE_DIRECTION_DOWN:
                  item = new DirectionBlock(BLOCK_TYPE_DIRECTION_DOWN);
                  break;
                case BLOCK_TYPE_DIRECTION_LEFT:
                  item = new DirectionBlock(BLOCK_TYPE_DIRECTION_LEFT);
                  break;
                case BLOCK_TYPE_DIRECTION_RIGHT:
                  item = new DirectionBlock(BLOCK_TYPE_DIRECTION_RIGHT);
                  break;
                default:
                  item = new Border(blockCount, BLOCK_TYPE_BORDER);
              }
              if ((_ref2 = currentLevel[x]) == null) {
                currentLevel[x] = {};
              }
              item.setXY(x, y);
              currentLevel[x][y] = item;
              _results1.push(canvasElements[item.id] = item);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      return canvas.valid = false;
    };

    Map.prototype.checkIfMapIsComplete = function() {
      var k1, k2, v1, v2;
      if (currentLevel[2][1].blockType === BLOCK_TYPE_ICE) {
        console.log('ICE!');
      }
      for (k1 in currentLevel) {
        v1 = currentLevel[k1];
        for (k2 in v1) {
          v2 = v1[k2];
          if (v2.blockType === BLOCK_TYPE_HOLE) {
            return false;
          }
        }
      }
      return true;
    };

    Map.prototype.isCellAvailableForMoveOver = function(y, x) {
      var _ref;
      if (typeof currentLevel[x] === 'object') {
        if ((_ref = currentLevel[x][y].blockType) === BLOCK_TYPE_HOLE || _ref === BLOCK_TYPE_ICE || _ref === BLOCK_TYPE_DIRECTION_DOWN || _ref === BLOCK_TYPE_DIRECTION_LEFT || _ref === BLOCK_TYPE_DIRECTION_RIGHT || _ref === BLOCK_TYPE_DIRECTION_UP) {
          return true;
        }
      }
      return false;
    };

    Map.prototype.updateBlockPositionOnMap = function(blockObj) {
      var hole;
      if (blockObj.canvasX / BLOCK_SIZE > blockObj.x || (blockObj.canvasX / BLOCK_SIZE) === (blockObj.x - 1)) {
        blockObj.x = ~~(blockObj.canvasX / BLOCK_SIZE);
      }
      if ((blockObj.canvasY / BLOCK_SIZE) > blockObj.y || (blockObj.canvasY / BLOCK_SIZE) === (blockObj.y - 1)) {
        blockObj.y = ~~(blockObj.canvasY / BLOCK_SIZE);
      }
      if (blockObj.x * BLOCK_SIZE === blockObj.canvasX && blockObj.y * BLOCK_SIZE === blockObj.canvasY) {
        switch (currentLevel[blockObj.x][blockObj.y].blockType) {
          case BLOCK_TYPE_HOLE:
            blockObj.movable = false;
            currentLevel[blockObj.x][blockObj.y] = blockObj;
            break;
          case BLOCK_TYPE_DIRECTION_UP:
            blockObj.setDirection('up');
            break;
          case BLOCK_TYPE_DIRECTION_DOWN:
            blockObj.setDirection('down');
            break;
          case BLOCK_TYPE_DIRECTION_LEFT:
            blockObj.setDirection('left');
            break;
          case BLOCK_TYPE_DIRECTION_RIGHT:
            blockObj.setDirection('right');
            break;
          case BLOCK_TYPE_ICE:
            if (blockObj.blockType === BLOCK_TYPE_FIRE) {
              hole = new BlockHole(BLOCK_TYPE_HOLE);
              hole.setXY(canvasElements[currentLevel[blockObj.x][blockObj.y].id].x, canvasElements[currentLevel[blockObj.x][blockObj.y].id].y);
              canvasElements[currentLevel[blockObj.x][blockObj.y].id] = hole;
            }
        }
      }
      return true;
    };

    return Map;

  })();

  DrawableBlock = (function() {

    function DrawableBlock() {}

    DrawableBlock.prototype.drawOnCtx = function(ctx, x, y, w, h) {
      var gradient;
      ctx.beginPath();
      ctx.rect(x, y, w, h);
      ctx.closePath();
      ctx.fill();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, ctx.fillStyle);
      gradient.addColorStop(1, ctx.fillStyle);
      ctx.shadowBlur = 1;
      ctx.shadowColor = "black";
      ctx.fillStyle = gradient;
      ctx.fill();
      return this.drawSymbol(ctx, x, y, w, h);
    };

    DrawableBlock.prototype.drawSymbol = function(ctx, x, y, w, h) {
      switch (this.blockType) {
        case BLOCK_TYPE_ICE:
          return this.drawIceSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_FIRE:
          return this.drawFireSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_DIRECTION_DOWN:
          return this.drawDownSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_DIRECTION_LEFT:
          return this.drawLeftSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_DIRECTION_RIGHT:
          return this.drawRightSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_DIRECTION_UP:
          return this.drawUpSymbol(ctx, x, y, w, h);
        case BLOCK_TYPE_CONTAINER:
          return this.drawContainerSymbol(ctx, x, y, w, h);
      }
    };

    DrawableBlock.prototype.drawContainerSymbol = function(ctx, x, y, w, h) {
      if (this.blockCount > 0) {
        ctx.fillStyle = "black";
        ctx.font = "bold 16px Arial";
        return ctx.fillText(this.blockCount + ":" + this.blockChildType, x + w / 10, y + h / 2);
      } else {
        return this.drawUndoSymbol(ctx, x, y, w, h);
      }
    };

    DrawableBlock.prototype.drawUndoSymbol = function(ctx, x, y, w, h) {
      ctx.fillStyle = "black";
      ctx.font = "bold 16px Arial";
      ctx.fillText("UNDO", x + w / 10, y + h / 2);
    };

    DrawableBlock.prototype.drawIceSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y + offset);
      ctx.lineTo(x + w - offset * 2, y + h / 2);
      ctx.lineTo(x + w / 2, y + h - offset);
      ctx.lineTo(x + offset * 2, y + h / 2);
      ctx.closePath();
      ctx.shadowBlur = 0;
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FFFFFF");
      gradient.addColorStop(1, "#9fbae0");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawFireSymbol = function(ctx, x, y, w, h) {
      ctx.save();
      ctx.fillStyle = "#ff0000";
      ctx.beginPath();
      ctx.moveTo(292.0733337402344, 172);
      ctx.lineTo(312.53582763671875, 204.35079956054688);
      ctx.bezierCurveTo(351.8642578125, 267.0616455078125, 363.6740417480469, 313.51263427734375, 363.04449462890625, 402.94232177734375);
      ctx.bezierCurveTo(362.5291748046875, 476.1221008300781, 359.14666748046875, 494.9073181152344, 335.0704345703125, 560.2098083496094);
      ctx.bezierCurveTo(310.66961669921875, 626.3924865722656, 308.1097717285156, 641.0450134277344, 311.4997253417969, 696.2249450683594);
      ctx.lineTo(315.1260070800781, 758.0929260253906);
      ctx.lineTo(298.5487976074219, 724.0892028808594);
      ctx.bezierCurveTo(279.62249755859375, 685.7153625488281, 277.7745056152344, 644.1753234863281, 288.7060852050781, 499.52252197265625);
      ctx.lineTo(295.6995849609375, 407.19281005859375);
      ctx.lineTo(270.0567321777344, 359.7292175292969);
      ctx.bezierCurveTo(243.81228637695312, 311.1573181152344, 177.926025390625, 242.8827667236328, 188.72482299804688, 275.4281311035156);
      ctx.bezierCurveTo(196.4998779296875, 298.8606262207031, 174.48806762695312, 350.89849853515625, 121.63897705078125, 434.3486022949219);
      ctx.bezierCurveTo(55.970603942871094, 538.0405578613281, 42, 578.5638732910156, 46.52350997924805, 648.5252380371094);
      ctx.bezierCurveTo(51.99464797973633, 733.1406555175781, 98.66461944580078, 810.2752990722656, 179.91819763183594, 868.8414001464844);
      ctx.bezierCurveTo(206.4759521484375, 887.9836730957031, 228.52279663085938, 897.8863830566406, 245.19091796875, 897.8862609863281);
      ctx.lineTo(270.31573486328125, 897.8862609863281);
      ctx.lineTo(235.3482208251953, 863.1741027832031);
      ctx.bezierCurveTo(187.00404357910156, 815.3599548339844, 159.10643005371094, 756.3572692871094, 154.01629638671875, 691.5022888183594);
      ctx.bezierCurveTo(150.990478515625, 652.9480285644531, 152.53106689453125, 640.1369323730469, 159.45570373535156, 644.0386047363281);
      ctx.bezierCurveTo(164.6754608154297, 646.9795837402344, 168.7804718017578, 655.5267639160156, 168.7803955078125, 662.9295349121094);
      ctx.bezierCurveTo(168.7803955078125, 684.3775939941406, 215.21884155273438, 763.1204528808594, 249.07620239257812, 799.1808776855469);
      ctx.bezierCurveTo(266.14434814453125, 817.3595886230469, 302.24139404296875, 847.0287780761719, 329.1130065917969, 865.0632019042969);
      ctx.bezierCurveTo(375.73443603515625, 896.3520202636719, 380.41607666015625, 897.8863830566406, 435.5697326660156, 897.8862609863281);
      ctx.bezierCurveTo(467.3592834472656, 897.8862609863281, 491.9608154296875, 895.3360900878906, 490.22271728515625, 892.2190246582031);
      ctx.bezierCurveTo(440.53924560546875, 803.1229553222656, 438.1243591308594, 795.8184509277344, 438.4189758300781, 735.4237976074219);
      ctx.bezierCurveTo(438.69122314453125, 679.5966491699219, 441.8666687011719, 669.1926574707031, 477.5307922363281, 599.4085998535156);
      ctx.bezierCurveTo(521.8492431640625, 512.6906433105469, 532.9354858398438, 474.21533203125, 533.2197875976562, 409.7903137207031);
      ctx.bezierCurveTo(533.6323852539062, 316.3744812011719, 484.8915710449219, 246.14523315429688, 391.0185241699219, 204.8230743408203);
      ctx.bezierCurveTo(362.2380676269531, 192.1541748046875, 328.20648193359375, 179.4442596435547, 315.385009765625, 176.72274780273438);
      ctx.lineTo(292.0733337402344, 172);
      ctx.closePath();
      ctx.moveTo(637.8634643554688, 418.0551452636719);
      ctx.lineTo(631.387939453125, 452.05889892578125);
      ctx.bezierCurveTo(622.22705078125, 500.43487548828125, 610.8256225585938, 523.4263610839844, 562.7479858398438, 591.8522644042969);
      ctx.bezierCurveTo(539.3870849609375, 625.1003112792969, 515.4966430664062, 663.4790954589844, 509.3901062011719, 677.0978698730469);
      ctx.bezierCurveTo(492.10345458984375, 715.6507873535156, 501.7059020996094, 794.4850158691406, 530.111572265625, 846.8805847167969);
      ctx.lineTo(553.6823120117188, 890.5660095214844);
      ctx.lineTo(564.0430297851562, 857.9790954589844);
      ctx.bezierCurveTo(572.0131225585938, 833.0603332519531, 589.8157958984375, 811.9314880371094, 640.194580078125, 768.2468566894531);
      ctx.bezierCurveTo(713.2570190429688, 704.8929138183594, 724.0380859375, 684.1929016113281, 724.11669921875, 606.2565612792969);
      ctx.bezierCurveTo(724.17431640625, 549.0911560058594, 707.4849243164062, 504.5606689453125, 668.1686401367188, 455.83709716796875);
      ctx.lineTo(637.8634643554688, 418.0551452636719);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      return ctx.restore();
    };

    DrawableBlock.prototype.drawFireSymbol2 = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y + offset);
      ctx.lineTo(x + w - offset * 2, y + h / 2);
      ctx.lineTo(x + w / 2, y + h - offset);
      ctx.lineTo(x + offset * 2, y + h / 2);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FF3333");
      gradient.addColorStop(1, "#9f3333");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawUpSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y + offset);
      ctx.lineTo(x + w - offset, y + h - offset);
      ctx.lineTo(x + offset, y + h - offset);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#fff");
      gradient.addColorStop(1, "#ccc");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawDownSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + offset, y + offset);
      ctx.lineTo(x + w - offset, y + offset);
      ctx.lineTo(x + w / 2, y + h - offset);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FF3333");
      gradient.addColorStop(1, "#9f3333");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawLeftSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + offset, y + h / 2);
      ctx.lineTo(x + w - offset, y + offset);
      ctx.lineTo(x + w - offset, y + h - offset);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FF3333");
      gradient.addColorStop(1, "#9f3333");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    DrawableBlock.prototype.drawRightSymbol = function(ctx, x, y, w, h) {
      var gradient, offset;
      offset = ~~(w / 10);
      ctx.beginPath();
      ctx.moveTo(x + offset, y + offset);
      ctx.lineTo(x + w - offset, y + h / 2);
      ctx.lineTo(x + offset, y + h - offset);
      ctx.closePath();
      gradient = ctx.createLinearGradient(x, y, w + x, y + h);
      gradient.addColorStop(0, "#FF3333");
      gradient.addColorStop(1, "#9f3333");
      ctx.fillStyle = gradient;
      return ctx.fill();
    };

    return DrawableBlock;

  })();

  MovableBlock = (function() {

    function MovableBlock() {}

    MovableBlock.prototype.enableBlock = function() {
      this.state = 'active';
      this.doEvent = 'moveBlock';
      return map.addListener(this);
    };

    MovableBlock.prototype.setDirection = function(direction) {
      this.direction = direction;
      if (this.state !== 'active') {
        return this.enableBlock();
      }
    };

    MovableBlock.prototype.getDirection = function() {
      return this.direction;
    };

    MovableBlock.prototype.updateBlockPosition = function() {};

    MovableBlock.prototype.moveBlock = function() {
      var a;
      a = this.canvasX + this.canvasY;
      switch (this.direction) {
        case 'left':
          if (map.isCellAvailableForMoveOver(this.y, this.x - 1)) {
            this.modifyCanvasX(-BLOCK_SPEED);
          }
          break;
        case 'right':
          if (map.isCellAvailableForMoveOver(this.y, this.x + 1)) {
            this.modifyCanvasX(BLOCK_SPEED);
          }
          break;
        case 'up':
          if (map.isCellAvailableForMoveOver(this.y - 1, this.x)) {
            this.modifyCanvasY(-BLOCK_SPEED);
          }
          break;
        case 'down':
          if (map.isCellAvailableForMoveOver(this.y + 1, this.x)) {
            this.modifyCanvasY(BLOCK_SPEED);
          }
          break;
        default:
          throw {
            message: 'no direction were set'
          };
      }
      if (this.canvasX + this.canvasY !== a) {
        canvas.valid = false;
      }
      return false;
    };

    MovableBlock.prototype.checkBlockStatus = function() {
      if (this.direction === false) {
        this.state = false;
        return map.deleteListener(this);
      }
    };

    MovableBlock.prototype.setMoveTo = function(moveToX, moveToY) {
      this.moveToX = moveToX;
      this.moveToY = moveToY;
    };

    MovableBlock;

    return MovableBlock;

  })();

  GenericBlock = (function(_super) {

    __extends(GenericBlock, _super);

    GenericBlock.mixin(ObjectHash);

    GenericBlock.mixin(MovableBlock);

    function GenericBlock(blockType) {
      this.id = getUniqId();
      this.blockType = blockType;
      this.x = 0;
      this.y = 0;
      this.canvasX = 0;
      this.canvasY = 0;
      this.movable = true;
      this.direction = false;
      this.width = BLOCK_SIZE;
      this.height = BLOCK_SIZE;
    }

    GenericBlock.prototype.modifyCanvasX = function(modifier) {
      var boundLeft, boundRight, moveDirection;
      moveDirection = modifier < 0 ? -1 : 1;
      if (this.nextDirectionModifier !== '') {
        if (this.direction === this.direction_old && currentLevel[this.x + moveDirection][this.y].blockType === BLOCK_TYPE_HOLE) {
          modifier = this.nextDirectionModifier;
          this.nextDirectionModifier = '';
        } else {
          this.nextDirectionModifier = '';
        }
      }
      this.canvasX += modifier;
      boundLeft = this.width * (~~(this.canvasX / this.width));
      boundRight = this.width * (~~(this.canvasX / this.width) + 1);
      if ((this.canvasX + modifier) < boundLeft && currentLevel[this.x + moveDirection][this.y].blockType === BLOCK_TYPE_HOLE) {
        this.nextDirectionModifier = boundLeft - this.canvasX;
      }
      if ((this.canvasX + modifier) >= boundRight && currentLevel[this.x + moveDirection][this.y].blockType === BLOCK_TYPE_HOLE) {
        this.nextDirectionModifier = boundRight - this.canvasX;
      }
      this.direction_old = this.direction;
      return map.updateBlockPositionOnMap(this);
    };

    GenericBlock.prototype.modifyCanvasY = function(modifier) {
      var boundBottom, boundTop, moveDirection, _ref, _ref1;
      moveDirection = modifier < 0 ? -1 : 1;
      if (this.nextDirectionModifier !== '') {
        if (this.direction === this.direction_old) {
          modifier = this.nextDirectionModifier;
          this.nextDirectionModifier = '';
        } else {
          this.nextDirectionModifier = '';
        }
      }
      this.canvasY += modifier;
      boundTop = this.height * (~~(this.canvasY / this.height));
      boundBottom = this.height * (~~(this.canvasY / this.height) + 1);
      if ((this.canvasY + modifier) < boundTop && ((_ref = currentLevel[this.x][this.y + moveDirection]) === BLOCK_TYPE_HOLE || _ref === BLOCK_TYPE_DIRECTION_UP || _ref === BLOCK_TYPE_DIRECTION_DOWN || _ref === BLOCK_TYPE_DIRECTION_LEFT || _ref === BLOCK_TYPE_DIRECTION_RIGHT)) {
        this.nextDirectionModifier = boundTop - this.canvasY;
      }
      if ((this.canvasY + modifier) > boundBottom && ((_ref1 = currentLevel[this.x][this.y + moveDirection]) === BLOCK_TYPE_HOLE || _ref1 === BLOCK_TYPE_DIRECTION_UP || _ref1 === BLOCK_TYPE_DIRECTION_DOWN || _ref1 === BLOCK_TYPE_DIRECTION_LEFT || _ref1 === BLOCK_TYPE_DIRECTION_RIGHT)) {
        this.nextDirectionModifier = boundBottom - this.canvasY;
      }
      this.direction_old = this.direction;
      return map.updateBlockPositionOnMap(this);
    };

    GenericBlock.prototype.setCanvasXY = function(canvasX, canvasY) {
      this.canvasX = canvasX;
      this.canvasY = canvasY;
    };

    GenericBlock.prototype.setXY = function(x, y) {
      this.x = x;
      this.y = y;
      this.canvasX = BLOCK_SIZE * this.x;
      return this.canvasY = BLOCK_SIZE * this.y;
    };

    return GenericBlock;

  })(DrawableBlock);

  DirectionBlock = (function(_super) {

    __extends(DirectionBlock, _super);

    function DirectionBlock(type) {
      DirectionBlock.__super__.constructor.call(this, type);
      this.blockColor = '#335577';
      this.transparency = 0.3;
    }

    return DirectionBlock;

  })(GenericBlock);

  IceBlock = (function(_super) {

    __extends(IceBlock, _super);

    function IceBlock() {
      IceBlock.__super__.constructor.call(this, BLOCK_TYPE_ICE);
      this.blockColor = '#000077';
      this.transparency = 0.3;
    }

    return IceBlock;

  })(GenericBlock);

  FireBlock = (function(_super) {

    __extends(FireBlock, _super);

    function FireBlock() {
      FireBlock.__super__.constructor.call(this, BLOCK_TYPE_FIRE);
      this.blockColor = '#FF1111';
      this.transparency = 0.3;
    }

    return FireBlock;

  })(GenericBlock);

  StopperBlock = (function(_super) {

    __extends(StopperBlock, _super);

    function StopperBlock() {
      StopperBlock.__super__.constructor.call(this, BLOCK_TYPE_STOPPER);
      this.blockColor = '#115090';
    }

    return StopperBlock;

  })(GenericBlock);

  AbstractBlockContainer = (function(_super) {
    var blockCount, blockType;

    __extends(AbstractBlockContainer, _super);

    blockType = '';

    blockCount = 0;

    function AbstractBlockContainer() {
      this.x = 0;
      this.y = 0;
      this.id = getUniqId();
      this.width = BLOCK_SIZE;
      this.height = BLOCK_SIZE;
    }

    AbstractBlockContainer.prototype.setCanvasXY = function(canvasX, canvasY) {
      this.canvasX = canvasX;
      this.canvasY = canvasY;
    };

    AbstractBlockContainer.prototype.setXY = function(x, y) {
      this.x = x;
      this.y = y;
      this.canvasX = BLOCK_SIZE * this.x;
      return this.canvasY = BLOCK_SIZE * this.y;
    };

    return AbstractBlockContainer;

  })(DrawableBlock);

  BlockContainer = (function(_super) {

    __extends(BlockContainer, _super);

    function BlockContainer(blockCount, blockContainerType, blockChildType) {
      this.blockContainerType = blockContainerType;
      this.blockChildType = blockChildType;
      BlockContainer.__super__.constructor.apply(this, arguments);
      this.blockCount = blockCount;
      this.blockType = BLOCK_TYPE_CONTAINER;
      this.blockChildTypeClass = Helper.getBlockClassName(blockChildType);
      this.blockList = [];
      this.blockColor = "#FFF";
    }

    BlockContainer.prototype.spawnBlocks = function() {
      var block, i, _i, _ref;
      for (i = _i = 0, _ref = this.blockCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        block = eval("new " + this.blockChildTypeClass + "()");
        block.setXY(this.x, this.y);
        canvasElements[block.id] = block;
        this.blockList.push(block);
      }
      this.blockCount = 0;
      return canvas.valid = false;
    };

    return BlockContainer;

  })(AbstractBlockContainer);

  BlockHole = (function(_super) {

    __extends(BlockHole, _super);

    function BlockHole() {
      BlockHole.__super__.constructor.apply(this, arguments);
      this.blockType = BLOCK_TYPE_HOLE;
      this.blockColor = "#eeeeee";
    }

    return BlockHole;

  })(AbstractBlockContainer);

  Border = (function(_super) {

    __extends(Border, _super);

    function Border() {
      this.className = 'border';
      Border.__super__.constructor.apply(this, arguments);
      this.blockType = BLOCK_TYPE_BORDER;
      this.blockColor = "#000000";
    }

    return Border;

  })(AbstractBlockContainer);

  Helper = (function() {

    function Helper() {}

    Helper.getEmptyBlockDesc = function(className) {
      if (className === BLOCK_TYPE_CONTAINER_FIRE) {
        return BLOCK_TYPE_CONTAINER_FIRE_EMPTY;
      }
      if (className === BLOCK_TYPE_CONTAINER_STOP) {
        return BLOCK_TYPE_CONTAINER_STOP_EMPTY;
      }
    };

    Helper.getNeighborCellByDirection = function(direction, x, y) {
      switch (direction) {
        case 'left':
          return [x - 1, y];
        case 'right':
          return [x + 1, y];
        case 'up':
          return [x, y - 1];
        case 'down':
          return [x, y + 1];
        default:
          throw {
            message: 'lolwut?'
          };
      }
    };

    Helper.getBlockClassName = function(className) {
      switch (className) {
        case BLOCK_TYPE_FIRE:
          return BLOCK_TYPE_FIRE_CLASSNAME;
        case BLOCK_TYPE_STOPPER:
          return BLOCK_TYPE_STOPPER_CLASSNAME;
        case BLOCK_TYPE_ICE:
          return BLOCK_TYPE_ICE_CLASSNAME;
      }
    };

    return Helper;

  })();

  level = parseInt(location.search.substr(1), 10) || 1;

  map = new Map(levels[level - 1]);

  levelPicker = document.getElementById('level');

  for (i = _i = 1, _ref = levels.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
    option = document.createElement('option');
    option.value = i;
    option.appendChild(document.createTextNode("Level " + i));
    levelPicker.appendChild(option);
  }

  levelPicker.value = level;

  levelPicker.addEventListener('change', function() {
    return location.search = '?' + levelPicker.value;
  });

  mapState = [];

  document.getElementById('reset').addEventListener('click', function() {
    console.debug(dumpMapState());
    return console.debug(currentLevel);
  });

  document.getElementById('debug').addEventListener('click', function() {
    return map.loadMap(mapState);
  });

  dumpMapState = function() {
    var j, k, tmp, v1, v2, _ref1;
    mapState = [];
    for (k in currentLevel) {
      v1 = currentLevel[k];
      if (typeof v1 === 'object') {
        tmp = '';
        for (j in v1) {
          v2 = v1[j];
          if (typeof v2 === 'object') {
            if ((_ref1 = mapState[j]) == null) {
              mapState[j] = '';
            }
            switch (v2.blockType) {
              case BLOCK_TYPE_CONTAINER:
                if (v2.blockContainerType === BLOCK_TYPE_CONTAINER_ICE) {
                  mapState[j] += v2.blockCount;
                } else if (v2.blockChildType) {
                  if (v2.blockCount > 0) {
                    mapState[j] += v2.blockContainerType;
                  } else {
                    mapState[j] += Helper.getEmptyBlockDesc(v2.blockContainerType);
                  }
                } else {
                  mapState[j] += v2.blockContainerType;
                }
                break;
              default:
                mapState[j] += v2.blockType;
            }
          }
        }
      }
    }
    return mapState;
  };

}).call(this);
